# Mock Exam 1 - Question 7

## Question 7: Helm Chart Deployment and Troubleshooting

On the student-node, a Helm chart repository is given under the `/opt/` path. It contains the files that describe a set of Kubernetes resources that can be deployed as a single unit. The files have some issues. Fix those issues and deploy them with the following specifications:

**Requirements:**

- The release name should be `webapp-color-apd`
- All the resources should be deployed on the `frontend-apd` namespace
- The service type should be **NodePort**
- Scale the deployment to **3**
- Application version should be **1.20.0**

> **NOTE**: Remember to make necessary changes in the `values.yaml` and `Chart.yaml` files according to the specifications, and, to fix the issues, inspect the template files.

## Solution

### Step 1: Navigate to Chart Directory

On the student-node:

```bash
cd /opt/<chart-name>
ls
```

You'll usually see:

- `Chart.yaml`
- `values.yaml`
- `templates/` (with Deployment, Service, etc.)

### Step 2: Update Chart.yaml

Open it:

```bash
vi Chart.yaml
```

Make sure:

```yaml
apiVersion: v2
name: webapp-color
description: A Helm chart for Kubernetes
type: application
version: 0.1.0          # chart version (leave as is or bump)
appVersion: "1.20.0"    # âœ… set as per requirement
```

### Step 3: Update values.yaml

Open it:

```bash
vi values.yaml
```

Update these fields:

```yaml
replicaCount: 3   # âœ… scale to 3

service:
  type: NodePort  # âœ… must expose as NodePort
  port: 8080

image:
  repository: kodekloud/webapp-color
  tag: v1
  pullPolicy: IfNotPresent
```

### Step 4: Create Namespace

```bash
kubectl create namespace frontend-apd
```

### Step 5: Deploy the Chart

```bash
helm install webapp-color-apd /opt/webapp-color-apd -n frontend-apd
```

## Explanation

### ðŸ”¹ 1. What Helm is

- **Helm** is a package manager for Kubernetes
- A **Helm chart** is a collection of YAML templates (`templates/*.yaml`) plus some metadata (`Chart.yaml`, `values.yaml`)
- When you run `helm install ...`, Helm takes those templates, fills in the values, and renders them into plain Kubernetes manifests that are then applied with `kubectl`
- Think of Helm like "kubectl apply but templated and parameterized"

### ðŸ”¹ 2. The Structure You Have

- `/opt/webapp-color-apd/Chart.yaml` â†’ defines chart metadata (name, appVersion, etc.)
- `/opt/webapp-color-apd/values.yaml` â†’ defines defaults like image, replicas, service type/port
- `/opt/webapp-color-apd/templates/*.yaml` â†’ resource templates (Deployment, Service, etc.)

### ðŸ”¹ 3. How Values Are Substituted

When Helm sees something like:

```yaml
metadata:
  name: {{ .Release.Name }}
```

It replaces the template variable with runtime values:

- `{{ .Release.Name }}` â†’ the name you used with `helm install` (`webapp-color-apd` in your case)
- `{{ .Chart.Name }}` â†’ the chart's name (from `Chart.yaml`)
- `{{ .Values.* }}` â†’ values coming from `values.yaml`

So your Service template:

```yaml
metadata:
  name: {{ .Values.service.Name }}
```

tried to look for a key `service.Name` in `values.yaml`. Since it doesn't exist, it rendered as an empty string, which Kubernetes rejects â†’ **"resource name may not be empty"**.
